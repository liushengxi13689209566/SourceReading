!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AR	Makefile	/^AR = ar -rc$/;"	m
ARSTATICLIB	Makefile	/^ARSTATICLIB = $(AR) $@.tmp $^ $(AR_FLAGS); \\$/;"	m
BUILDEXE	Makefile	/^BUILDEXE = $(CPP) $(BFLAGS) -o $@ $^ $(LINKS) $/;"	m
BUILDSHARELIB	Makefile	/^BUILDSHARELIB = $(CPPSHARE) $@.tmp $^ $(BS_FLAGS); \\$/;"	m
CCCOMPI	Makefile	/^CCCOMPI=$(CC) $(CFLAGS)$/;"	m
CCCOMPILE	Makefile	/^CCCOMPILE = $(CCCOMPI) $< $(FLAGS) $(INCLS) $(MTOOL_INCL) -o $@$/;"	m
CFLAGS	Makefile	/^CFLAGS= -g $(INCLS) -fPIC -DLINUX -pipe -c -fno-inline$/;"	m
CLEAN	Makefile	/^CLEAN = rm -f *.o $/;"	m
COBJS	Makefile	/^COBJS  = $(patsubst %.c,%.o,$(CSRCS))$/;"	m
COLIB_OBJS	Makefile	/^COLIB_OBJS=routine.o  coctx_swap.o coctx.o   $/;"	m
CPP	Makefile	/^CPP = $(CXX)$/;"	m
CPPCOMPI	Makefile	/^CPPCOMPI=$(CPP) $(CFLAGS) -Wno-deprecated$/;"	m
CPPCOMPILE	Makefile	/^CPPCOMPILE = $(CPPCOMPI) $< $(FLAGS) $(INCLS) $(MTOOL_INCL) -o $@$/;"	m
CPPOBJS	Makefile	/^CPPOBJS  = $(patsubst %.cpp,%.o,$(CPPSRCS))$/;"	m
CPPSHARE	Makefile	/^CPPSHARE = $(CPP) -fPIC -shared -O2 -pipe -L$(SRCROOT)\/solib\/ -o $/;"	m
CPPSRCS	Makefile	/^CPPSRCS  = $(wildcard *.cpp)$/;"	m
CSHARE	Makefile	/^CSHARE = $(CC) -fPIC -shared -O2 -pipe -L$(SRCROOT)\/solib\/ -o $/;"	m
CSRCS	Makefile	/^CSRCS  = $(wildcard *.c)$/;"	m
CallStackSize_	routine.h	/^	int CallStackSize_;               \/\/栈指针$/;"	m	class:libfly::RoutineEnv
CallStack_	routine.h	/^	Routine* CallStack_[ 128 ];       \/\/保存调用链$/;"	m	class:libfly::RoutineEnv
Cond_Callback	Conditional_variable.cpp	/^static void *Cond_Callback(Routine *routine)$/;"	f	namespace:libfly
Conditional_variable	Conditional_variable.cpp	/^Conditional_variable::Conditional_variable()$/;"	f	class:libfly::Conditional_variable
Conditional_variable	Conditional_variable.h	/^class Conditional_variable$/;"	c	namespace:libfly
Consumer	test.cpp	/^void * Consumer(void *arg)$/;"	f
DEBUG	Log.cpp	/^		const int DEBUG = 0; $/;"	m	namespace:libfly::LogInfo::LevelType	file:
DYNAMICLIBPATH	Makefile	/^DYNAMICLIBPATH=$(SRCROOT)\/solib$/;"	m
EAX	coctx.cpp	25;"	d	file:
ECX	coctx.cpp	26;"	d	file:
EIP	coctx.cpp	24;"	d	file:
ERROR	Log.cpp	/^		const int ERROR = 30;$/;"	m	namespace:libfly::LogInfo::LevelType	file:
ESP	coctx.cpp	23;"	d	file:
End_	routine.h	/^    char End_;                        \/\/协程是否结束$/;"	m	class:libfly::Routine
EventLoop	routine.cpp	/^EventLoop::EventLoop( Time_heap* time_heap, EventLoop_Function runInLoopFunction , void *arg )$/;"	f	class:libfly::EventLoop
EventLoop	routine.h	/^class EventLoop$/;"	c	namespace:libfly
EventLoop_Function	Callback.h	/^typedef int (*EventLoop_Function)(void *);$/;"	t	namespace:libfly
GetPid	routine.cpp	/^static pid_t GetPid()$/;"	f	namespace:libfly
INFO	Log.cpp	/^		const int INFO = 50;$/;"	m	namespace:libfly::LogInfo::LevelType	file:
Id_	routine.h	/^    unsigned long long Id_;           \/\/协程ID$/;"	m	class:libfly::Routine
IsMainRoutine_	routine.h	/^    char IsMainRoutine_;              \/\/是否是主协程$/;"	m	class:libfly::Routine
LOG_DEBUG	Log.h	31;"	d
LOG_ERROR	Log.h	30;"	d
LOG_INFO	Log.h	29;"	d
LOG_TRACE	Log.h	28;"	d
LevelType	Log.cpp	/^	namespace LevelType{\/\/less is more important.$/;"	n	namespace:libfly::LogInfo	file:
LevelType	Log.h	/^    namespace LevelType{\/\/less is more important.$/;"	n	namespace:libfly::LogInfo
Log	Log.cpp	/^Log::Log(std::string projectName)$/;"	f	class:libfly::Log
Log	Log.h	/^class Log$/;"	c	namespace:libfly
LogInfo	Log.cpp	/^namespace LogInfo$/;"	n	namespace:libfly	file:
LogInfo	Log.h	/^namespace LogInfo$/;"	n	namespace:libfly
MAIL_ROOT	Makefile	/^MAIL_ROOT=.$/;"	m
OBJS	Makefile	/^OBJS = $(CPPOBJS) $(COBJS)$/;"	m
PROGS	Makefile	/^PROGS = colib  test $/;"	m
Poller	Poller.cpp	/^Poller::Poller( TimerCallback  timerCallback , void * arg , int delay)$/;"	f	class:libfly::Poller
Poller	Poller.h	/^class Poller$/;"	c	namespace:libfly
Producer	test.cpp	/^void * Producer(void *arg)$/;"	f
R12	coctx.cpp	35;"	d	file:
R13	coctx.cpp	36;"	d	file:
R14	coctx.cpp	37;"	d	file:
R15	coctx.cpp	38;"	d	file:
R8	coctx.cpp	41;"	d	file:
R9	coctx.cpp	42;"	d	file:
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RBP	coctx.cpp	34;"	d	file:
RBX	coctx.cpp	30;"	d	file:
RCX	coctx.cpp	40;"	d	file:
RDI	coctx.cpp	31;"	d	file:
RDX	coctx.cpp	39;"	d	file:
RIP	coctx.cpp	29;"	d	file:
RSI	coctx.cpp	32;"	d	file:
RSP	coctx.cpp	28;"	d	file:
Routine	routine.cpp	/^Routine::Routine( RoutineEnv * env, $/;"	f	class:libfly::Routine
Routine	routine.h	/^class Routine $/;"	c	namespace:libfly
RoutineAttr	routine.h	/^    RoutineAttr()$/;"	f	class:libfly::RoutineAttr
RoutineAttr	routine.h	/^class RoutineAttr\/\/协程的参数$/;"	c	namespace:libfly
RoutineEnv	routine.h	/^class RoutineEnv$/;"	c	namespace:libfly
RoutineFunc	routine.cpp	/^static int RoutineFunc( Routine* routine,void * )$/;"	f	namespace:libfly
Routine_Function	Callback.h	/^typedef void *(*Routine_Function)( void * );$/;"	t	namespace:libfly
Routine_Id	routine.cpp	/^unsigned long long Routine_Id=0;$/;"	m	namespace:libfly	file:
SRCROOT	Makefile	/^SRCROOT=.$/;"	m
SRCS	Makefile	/^SRCS = $(CPPSRCS) $(CSRCS)$/;"	m
STATICLIBPATH	Makefile	/^STATICLIBPATH=$(SRCROOT)\/lib$/;"	m
StackMemry	routine.cpp	/^StackMemry::StackMemry(int stack_size)$/;"	f	class:libfly::StackMemry
StackMemry	routine.h	/^class StackMemry$/;"	c	namespace:libfly
Start_	routine.h	/^    char Start_;                      \/\/协程是否运行$/;"	m	class:libfly::Routine
TRACE	Log.cpp	/^		const int TRACE = 90;$/;"	m	namespace:libfly::LogInfo::LevelType	file:
Time_heap	Time_heap.cpp	/^Time_heap::Time_heap(int cap)$/;"	f	class:libfly::Time_heap
Time_heap	Time_heap.h	/^class Time_heap$/;"	c	namespace:libfly
TimerCallback	Callback.h	/^typedef void *(*TimerCallback)( Routine * );$/;"	t	namespace:libfly
_CONDITIONAL_VARIABLE_H	Conditional_variable.h	9;"	d
_LOG_H	Log.h	18;"	d
_POLLER_H	Poller.h	9;"	d
_ROUTINE_H	routine.h	9;"	d
_TIME_HEAP	Time_heap.h	2;"	d
__CO_CLOSURE_H__	closure.h	20;"	d
__CO_CTX_H__	coctx.h	20;"	d
add_timer	Time_heap.cpp	/^void Time_heap::add_timer( TimerCallback timerCallback,  void* arg,  int delay)$/;"	f	class:libfly::Time_heap
add_timer	Time_heap.cpp	/^void Time_heap::add_timer(heap_timer* timer)$/;"	f	class:libfly::Time_heap
arg_	Poller.h	/^    void * arg_;$/;"	m	class:libfly::Poller
arg_	Time_heap.h	/^    void* arg_;$/;"	m	class:libfly::heap_timer
arg_	routine.h	/^    void *arg_;$/;"	m	class:libfly::EventLoop
arg_	routine.h	/^    void* arg_;                       \/\/协程块函数对应的参数$/;"	m	class:libfly::Routine
array	Time_heap.h	/^    heap_timer** array;$/;"	m	class:libfly::Time_heap
capacity	Time_heap.h	/^    int capacity;$/;"	m	class:libfly::Time_heap
co_func	closure.h	79;"	d
co_func_end	closure.h	92;"	d
co_ref	closure.h	63;"	d
co_swap	routine.cpp	/^void co_swap(Routine* Current_Routine, Routine* Pending_Routine)$/;"	f	namespace:libfly
coctx_init	coctx.cpp	/^int coctx_init( coctx_t *ctx )$/;"	f
coctx_make	coctx.cpp	/^int coctx_make( coctx_t *ctx,coctx_pfn_t pfn,const void *s,const void *s1 )$/;"	f
coctx_param_t	coctx.h	/^struct coctx_param_t$/;"	s
coctx_pfn_t	coctx.h	/^typedef void* (*coctx_pfn_t)( void* s, void* s2 );$/;"	t
coctx_swap	coctx_swap.S	/^coctx_swap:$/;"	l
coctx_t	coctx.h	/^struct coctx_t$/;"	s
comac_arg_n	closure.h	31;"	d
comac_argc	closure.h	35;"	d
comac_args_seqs	closure.h	32;"	d
comac_get_args_cnt	closure.h	30;"	d
comac_join	closure.h	36;"	d
comac_join_1	closure.h	33;"	d
con_param_typeof	closure.h	57;"	d
ctx_	routine.h	/^    coctx_t ctx_;                     \/\/用来保存CPU上下文$/;"	m	class:libfly::Routine
cur_size	Time_heap.h	/^    int cur_size;$/;"	m	class:libfly::Time_heap
dbg_flag	routine.cpp	/^void dbg_flag(int line)$/;"	f	namespace:libfly
dbg_print	routine.cpp	/^void dbg_print(char * str)$/;"	f	namespace:libfly
debug	Log.cpp	/^void Log::debug(std::string file , std::string function, int line , std::string strDebug)$/;"	f	class:libfly::Log
decl_typeof	closure.h	51;"	d
decl_typeof	closure.h	53;"	d
del_timer	Time_heap.cpp	/^void Time_heap::del_timer(heap_timer* timer)$/;"	f	class:libfly::Time_heap
delay_	Poller.h	/^    int delay_;$/;"	m	class:libfly::Poller
empty	Time_heap.h	/^    bool empty() const $/;"	f	class:libfly::Time_heap
env_	routine.h	/^    RoutineEnv * env_;                \/\/当前协程环境$/;"	m	class:libfly::Routine
error	Log.cpp	/^void Log::error(std::string file , std::string function, int line , std::string strError)$/;"	f	class:libfly::Log
expire	Time_heap.h	/^    time_t expire;$/;"	m	class:libfly::heap_timer
fileMaxSize_	Log.h	/^    long   fileMaxSize_;$/;"	m	class:libfly::Log
fileName_	Log.h	/^    std::string fileName_;$/;"	m	class:libfly::Log
fileOldName_	Log.h	/^    std::string fileOldName_;$/;"	m	class:libfly::Log
g_arryEnvPerThread	routine.cpp	/^static RoutineEnv* g_arryEnvPerThread[ 204800 ] = {0};$/;"	m	namespace:libfly	file:
getFileSize	Log.cpp	/^long Log::getFileSize() {$/;"	f	class:libfly::Log
getId	routine.h	/^    unsigned long long getId() const  \/\/获取协程ID$/;"	f	class:libfly::Routine
get_curr_routine	routine.cpp	/^Routine * get_curr_routine()$/;"	f	namespace:libfly
get_curr_thread_env	routine.cpp	/^RoutineEnv* get_curr_thread_env()$/;"	f	namespace:libfly
getcapacity	Time_heap.h	/^    int getcapacity() const$/;"	f	class:libfly::Time_heap
getcur_size	Time_heap.h	/^    int getcur_size() const $/;"	f	class:libfly::Time_heap
getfileName	Log.h	/^    std::string getfileName() const$/;"	f	class:libfly::Log
getfileOldName	Log.h	/^    std::string getfileOldName() const$/;"	f	class:libfly::Log
getoutputLevel	Log.h	/^    int getoutputLevel()$/;"	f	class:libfly::Log
getprojectName	Log.h	/^    std::string getprojectName() const$/;"	f	class:libfly::Log
heap_timer	Time_heap.cpp	/^heap_timer::heap_timer( TimerCallback timerCallback,  void* arg,  int delay)$/;"	f	class:libfly::heap_timer
heap_timer	Time_heap.h	/^class heap_timer\/\/定时器类$/;"	c	namespace:libfly
impl_typeof	closure.h	55;"	d
impl_typeof_cpy	closure.h	56;"	d
info	Log.cpp	/^void Log::info(std::string file , std::string function, int line, std::string strInfo)$/;"	f	class:libfly::Log
init_curr_thread_env	routine.cpp	/^void init_curr_thread_env()$/;"	f	namespace:libfly
kEIP	coctx.cpp	/^	kEIP = 0,$/;"	e	enum:__anon1	file:
kESP	coctx.cpp	/^	kESP = 7,$/;"	e	enum:__anon1	file:
kRDI	coctx.cpp	/^	kRDI = 7,$/;"	e	enum:__anon2	file:
kRETAddr	coctx.cpp	/^	kRETAddr = 9,$/;"	e	enum:__anon2	file:
kRSI	coctx.cpp	/^	kRSI = 8,$/;"	e	enum:__anon2	file:
kRSP	coctx.cpp	/^	kRSP = 13,$/;"	e	enum:__anon2	file:
libfly	Callback.h	/^namespace libfly$/;"	n
libfly	Conditional_variable.cpp	/^namespace libfly$/;"	n	file:
libfly	Conditional_variable.h	/^namespace libfly$/;"	n
libfly	Log.cpp	/^namespace libfly$/;"	n	file:
libfly	Log.h	/^namespace libfly$/;"	n
libfly	Poller.cpp	/^namespace libfly$/;"	n	file:
libfly	Poller.h	/^namespace libfly$/;"	n
libfly	Time_heap.cpp	/^namespace libfly$/;"	n	file:
libfly	Time_heap.h	/^namespace libfly$/;"	n
libfly	routine.cpp	/^namespace libfly$/;"	n	file:
libfly	routine.h	/^namespace libfly$/;"	n
limitFileSize	Log.cpp	/^void Log::limitFileSize()$/;"	f	class:libfly::Log
loop	routine.cpp	/^void EventLoop::loop()$/;"	f	class:libfly::EventLoop
main	test.cpp	/^int main()$/;"	f
notify_all	Conditional_variable.cpp	/^void Conditional_variable::notify_all()$/;"	f	class:libfly::Conditional_variable
notify_one	Conditional_variable.cpp	/^void Conditional_variable::notify_one()$/;"	f	class:libfly::Conditional_variable
occupy_	routine.h	/^    Routine* occupy_;$/;"	m	class:libfly::RoutineEnv
occupy_co_	routine.h	/^    Routine* occupy_co_;     \/\/当前协程指针$/;"	m	class:libfly::StackMemry
outputInfo	Log.cpp	/^void Log::outputInfo(int _outputLevel, std::string filePos ,std::string function, int line , std::string strInfo)$/;"	f	class:libfly::Log
outputLevel_	Log.h	/^    int    outputLevel_;$/;"	m	class:libfly::Log
param_init_typeof	closure.h	58;"	d
pending_	routine.h	/^	Routine* pending_;$/;"	m	class:libfly::RoutineEnv
pfn_	routine.h	/^    Routine_Function pfn_;            \/\/协程块函数$/;"	m	class:libfly::Routine
pop_timer	Time_heap.cpp	/^void Time_heap::pop_timer()$/;"	f	class:libfly::Time_heap
product	test.cpp	/^int product;$/;"	v
projectName_	Log.h	/^    std::string projectName_;$/;"	m	class:libfly::Log
push_down	Time_heap.cpp	/^void Time_heap::push_down(int hole)$/;"	f	class:libfly::Time_heap
regs	coctx.h	/^	void *regs[ 8 ];$/;"	m	struct:coctx_t
repeat	closure.h	47;"	d
repeat_0	closure.h	39;"	d
repeat_1	closure.h	40;"	d
repeat_2	closure.h	41;"	d
repeat_3	closure.h	42;"	d
repeat_4	closure.h	43;"	d
repeat_5	closure.h	44;"	d
repeat_6	closure.h	45;"	d
resize	Time_heap.cpp	/^void Time_heap::resize()$/;"	f	class:libfly::Time_heap
resume	routine.cpp	/^void Routine::resume()$/;"	f	class:libfly::Routine
routines_	Conditional_variable.h	/^    std::queue<heap_timer*> routines_;$/;"	m	class:libfly::Conditional_variable
runInLoop	routine.cpp	/^void EventLoop::runInLoop()$/;"	f	class:libfly::EventLoop
runInLoopFunction_	routine.h	/^    EventLoop_Function runInLoopFunction_; $/;"	m	class:libfly::EventLoop
runOutTimeEvent	Time_heap.cpp	/^void Time_heap::runOutTimeEvent()$/;"	f	class:libfly::Time_heap
s1	coctx.h	/^	const void *s1;$/;"	m	struct:coctx_param_t
s2	coctx.h	/^	const void *s2;$/;"	m	struct:coctx_param_t
save_buffer_	routine.h	/^    char* save_buffer_;               \/\/buff$/;"	m	class:libfly::Routine
save_size_	routine.h	/^    unsigned int save_size_;          \/\/buff大小$/;"	m	class:libfly::Routine
setId	routine.h	/^    void setId(unsigned long long Id) \/\/设置协程ID$/;"	f	class:libfly::Routine
setfileName	Log.h	/^    void setfileName(const std::string fileName)$/;"	f	class:libfly::Log
setprojectName	Log.h	/^    void setprojectName(const std::string projectName)$/;"	f	class:libfly::Log
size_	Conditional_variable.h	/^    int size_;     $/;"	m	class:libfly::Conditional_variable
ss_size	coctx.h	/^	size_t ss_size;$/;"	m	struct:coctx_t
ss_sp	coctx.h	/^	char *ss_sp;$/;"	m	struct:coctx_t
stCoClosure_t	closure.h	/^struct stCoClosure_t $/;"	s
stack_bp_	routine.h	/^	char*    stack_bp_;      \/\/stack_buffer + stack_size$/;"	m	class:libfly::StackMemry
stack_buffer_	routine.h	/^	char*    stack_buffer_;  \/\/栈空间$/;"	m	class:libfly::StackMemry
stack_memry_	routine.h	/^    StackMemry* stack_memry_;         \/\/协程运行栈内存$/;"	m	class:libfly::Routine
stack_size_	routine.h	/^	int      stack_size_;    \/\/栈大小$/;"	m	class:libfly::StackMemry
stack_size_	routine.h	/^    int stack_size_; \/\/栈大小$/;"	m	class:libfly::RoutineAttr
stack_sp_	routine.h	/^    char* stack_sp_;                  \/\/顶指针$/;"	m	class:libfly::Routine
time_heap_	Poller.h	/^    Time_heap * time_heap_;$/;"	m	class:libfly::Poller
time_heap_	routine.h	/^    Time_heap* time_heap_;$/;"	m	class:libfly::EventLoop
time_heap_	routine.h	/^    Time_heap* time_heap_;$/;"	m	class:libfly::RoutineEnv
timerCallback	test.cpp	/^void *timerCallback(Routine * routine)$/;"	f
timerCallback_	Poller.h	/^    TimerCallback timerCallback_;$/;"	m	class:libfly::Poller
timerCallback_	Time_heap.h	/^    TimerCallback timerCallback_;$/;"	m	class:libfly::heap_timer
top	Time_heap.cpp	/^heap_timer* Time_heap::top() const $/;"	f	class:libfly::Time_heap
trace	Log.cpp	/^void Log::trace(std::string file , std::string function, int line,std::string strTrace)$/;"	f	class:libfly::Log
wait	Conditional_variable.cpp	/^void Conditional_variable::wait()$/;"	f	class:libfly::Conditional_variable
writeTime	Log.cpp	/^void Log::writeTime(std::ofstream &file)$/;"	f	class:libfly::Log
yield	routine.cpp	/^void Routine::yield()$/;"	f	class:libfly::Routine
yield_current_thread	routine.cpp	/^void yield_current_thread()$/;"	f	namespace:libfly
yield_env	routine.cpp	/^void yield_env(RoutineEnv* env_)$/;"	f	namespace:libfly
~Conditional_variable	Conditional_variable.cpp	/^Conditional_variable::~Conditional_variable()$/;"	f	class:libfly::Conditional_variable
~EventLoop	routine.cpp	/^EventLoop::~EventLoop()$/;"	f	class:libfly::EventLoop
~Log	Log.cpp	/^Log::~Log()$/;"	f	class:libfly::Log
~Poller	Poller.cpp	/^Poller::~Poller()$/;"	f	class:libfly::Poller
~Routine	routine.cpp	/^Routine::~Routine()$/;"	f	class:libfly::Routine
~Time_heap	Time_heap.cpp	/^Time_heap::~Time_heap()$/;"	f	class:libfly::Time_heap
